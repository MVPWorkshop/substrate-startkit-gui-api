import PalletValidatorSetConfig from '../pallets/configs/pallet_validator_set.config';
import SubstrateRuntimeUtil from '../utils/substrateRuntime.util';

const runtimeLibCode = '#![cfg_attr(not(feature = \"std\"), no_std)]\n\/\/ `construct_runtime!` does a lot of recursion and requires us to increase the limit to 256.\n#![recursion_limit=\"256\"]\n\n\/\/ Make the WASM binary available.\n#[cfg(feature = \"std\")]\ninclude!(concat!(env!(\"OUT_DIR\"), \"\/wasm_binary.rs\"));\n\nuse sp_std::prelude::*;\nuse sp_core::{crypto::KeyTypeId, OpaqueMetadata};\nuse sp_runtime::{\n\tApplyExtrinsicResult, generic, create_runtime_str, impl_opaque_keys, MultiSignature,\n\ttransaction_validity::{TransactionValidity, TransactionSource}, ModuleId\n};\nuse sp_runtime::traits::{\n\tBlakeTwo256, Block as BlockT, IdentityLookup, Verify, IdentifyAccount, NumberFor, Saturating,\n};\nuse sp_api::impl_runtime_apis;\nuse sp_consensus_aura::sr25519::AuthorityId as AuraId;\nuse pallet_grandpa::{AuthorityId as GrandpaId, AuthorityList as GrandpaAuthorityList};\nuse pallet_grandpa::fg_primitives;\nuse sp_version::RuntimeVersion;\n#[cfg(feature = \"std\")]\nuse sp_version::NativeVersion;\n\n\/\/ A few exports that help ease life for downstream crates.\n#[cfg(any(feature = \"std\", test))]\npub use sp_runtime::BuildStorage;\npub use pallet_timestamp::Call as TimestampCall;\npub use pallet_balances::Call as BalancesCall;\npub use sp_runtime::{Permill, Perbill, Percent};\npub use frame_support::{\n\tconstruct_runtime, parameter_types, StorageValue,\n\ttraits::{KeyOwnerProofSystem, Randomness, LockIdentifier, EnsureOrigin},\n\tweights::{\n\t\tWeight, IdentityFee,\n\t\tconstants::{BlockExecutionWeight, ExtrinsicBaseWeight, RocksDbWeight, WEIGHT_PER_SECOND},\n\t},\n};\nuse frame_system::{EnsureRoot, EnsureOneOf, EnsureNever, EnsureSigned};\nuse sp_runtime::transaction_validity::{ TransactionPriority };\nimpl<C> frame_system::offchain::SendTransactionTypes<C> for Runtime where Call: From<C> {\n\ttype Extrinsic = UncheckedExtrinsic;\n\ttype OverarchingCall = Call;\n}\n\n\/\/Additional code\n\n\/\/\/ An index to a block.\npub type BlockNumber = u32;\n\n\/\/\/ Alias to 512-bit hash when used in the context of a transaction signature on the chain.\npub type Signature = MultiSignature;\n\n\/\/\/ Some way of identifying an account on the chain. We intentionally make it equivalent\n\/\/\/ to the public key of our transaction signing scheme.\npub type AccountId = <<Signature as Verify>::Signer as IdentifyAccount>::AccountId;\n\n\/\/\/ The type for looking up accounts. We don\'t expect more than 4 billion of them, but you\n\/\/\/ never know...\npub type AccountIndex = u32;\n\n\/\/\/ Balance of an account.\npub type Balance = u128;\n\n\/\/\/ Index of a transaction in the chain.\npub type Index = u32;\n\n\/\/\/ A hash of some data used by the chain.\npub type Hash = sp_core::H256;\n\n\/\/\/ Digest item type.\npub type DigestItem = generic::DigestItem<Hash>;\n\n\/\/\/ Opaque types. These are used by the CLI to instantiate machinery that don\'t need to know\n\/\/\/ the specifics of the runtime. They can then be made to be agnostic over specific formats\n\/\/\/ of data like extrinsics, allowing for them to continue syncing the network through upgrades\n\/\/\/ to even the core data structures.\npub mod opaque {\n\tuse super::*;\n\n\tpub use sp_runtime::OpaqueExtrinsic as UncheckedExtrinsic;\n\n\t\/\/\/ Opaque block header type.\n\tpub type Header = generic::Header<BlockNumber, BlakeTwo256>;\n\t\/\/\/ Opaque block type.\n\tpub type Block = generic::Block<Header, UncheckedExtrinsic>;\n\t\/\/\/ Opaque block identifier type.\n\tpub type BlockId = generic::BlockId<Block>;\n\n\timpl_opaque_keys! {\n\t\tpub struct SessionKeys {\n\t\t\tpub aura: Aura,\n\t\t\tpub grandpa: Grandpa,\n\t\t}\n\t}\n}\n\npub const VERSION: RuntimeVersion = RuntimeVersion {\n\tspec_name: create_runtime_str!(\"node-template\"),\n\timpl_name: create_runtime_str!(\"node-template\"),\n\tauthoring_version: 1,\n\tspec_version: 1,\n\timpl_version: 1,\n\tapis: RUNTIME_API_VERSIONS,\n\ttransaction_version: 1,\n};\n\npub const MILLISECS_PER_BLOCK: u64 = 6000;\n\npub const SLOT_DURATION: u64 = MILLISECS_PER_BLOCK;\n\n\/\/ Time is measured by number of blocks.\npub const MINUTES: BlockNumber = 60_000 \/ (MILLISECS_PER_BLOCK as BlockNumber);\npub const HOURS: BlockNumber = MINUTES * 60;\npub const DAYS: BlockNumber = HOURS * 24;\n\n\/\/\/ The version information used to identify this runtime when compiled natively.\n#[cfg(feature = \"std\")]\npub fn native_version() -> NativeVersion {\n\tNativeVersion {\n\t\truntime_version: VERSION,\n\t\tcan_author_with: Default::default(),\n\t}\n}\n\nparameter_types! {\n\tpub const BlockHashCount: BlockNumber = 2400;\n\t\/\/\/ We allow for 2 seconds of compute with a 6 second average block time.\n\tpub const MaximumBlockWeight: Weight = 2 * WEIGHT_PER_SECOND;\n\tpub const AvailableBlockRatio: Perbill = Perbill::from_percent(75);\n\t\/\/\/ Assume 10% of weight for average on_initialize calls.\n\tpub MaximumExtrinsicWeight: Weight = AvailableBlockRatio::get()\n\t\t.saturating_sub(Perbill::from_percent(10)) * MaximumBlockWeight::get();\n\tpub const MaximumBlockLength: u32 = 5 * 1024 * 1024;\n\tpub const Version: RuntimeVersion = VERSION;\n}\n\n\/\/ Configure FRAME pallets to include in runtime.\n\nimpl frame_system::Trait for Runtime {\n\t\/\/\/ The basic call filter to use in dispatchable.\n\ttype BaseCallFilter = ();\n\t\/\/\/ The identifier used to distinguish between accounts.\n\ttype AccountId = AccountId;\n\t\/\/\/ The aggregated dispatch type that is available for extrinsics.\n\ttype Call = Call;\n\t\/\/\/ The lookup mechanism to get account ID from whatever is passed in dispatchers.\n\ttype Lookup = IdentityLookup<AccountId>;\n\t\/\/\/ The index type for storing how many extrinsics an account has signed.\n\ttype Index = Index;\n\t\/\/\/ The index type for blocks.\n\ttype BlockNumber = BlockNumber;\n\t\/\/\/ The type for hashing blocks and tries.\n\ttype Hash = Hash;\n\t\/\/\/ The hashing algorithm used.\n\ttype Hashing = BlakeTwo256;\n\t\/\/\/ The header type.\n\ttype Header = generic::Header<BlockNumber, BlakeTwo256>;\n\t\/\/\/ The ubiquitous event type.\n\ttype Event = Event;\n\t\/\/\/ The ubiquitous origin type.\n\ttype Origin = Origin;\n\t\/\/\/ Maximum number of block number to block hash mappings to keep (oldest pruned first).\n\ttype BlockHashCount = BlockHashCount;\n\t\/\/\/ Maximum weight of each block.\n\ttype MaximumBlockWeight = MaximumBlockWeight;\n\t\/\/\/ The weight of database operations that the runtime can invoke.\n\ttype DbWeight = RocksDbWeight;\n\t\/\/\/ The weight of the overhead invoked on the block import process, independent of the\n\t\/\/\/ extrinsics included in that block.\n\ttype BlockExecutionWeight = BlockExecutionWeight;\n\t\/\/\/ The base weight of any extrinsic processed by the runtime, independent of the\n\t\/\/\/ logic of that extrinsic. (Signature verification, nonce increment, fee, etc...)\n\ttype ExtrinsicBaseWeight = ExtrinsicBaseWeight;\n\t\/\/\/ The maximum weight that a single extrinsic of `Normal` dispatch class can have,\n\t\/\/\/ idependent of the logic of that extrinsics. (Roughly max block weight - average on\n\t\/\/\/ initialize cost).\n\ttype MaximumExtrinsicWeight = MaximumExtrinsicWeight;\n\t\/\/\/ Maximum size of all encoded transactions (in bytes) that are allowed in one block.\n\ttype MaximumBlockLength = MaximumBlockLength;\n\t\/\/\/ Portion of the block weight that is available to all normal transactions.\n\ttype AvailableBlockRatio = AvailableBlockRatio;\n\t\/\/\/ Version of the runtime.\n\ttype Version = Version;\n\t\/\/\/ Converts a module to the index of the module in `construct_runtime!`.\n\t\/\/\/\n\t\/\/\/ This type is being generated by `construct_runtime!`.\n\ttype PalletInfo = PalletInfo;\n\t\/\/\/ What to do if a new account is created.\n\ttype OnNewAccount = ();\n\t\/\/\/ What to do if an account is fully reaped from the system.\n\ttype OnKilledAccount = ();\n\t\/\/\/ The data to be stored in an account.\n\ttype AccountData = pallet_balances::AccountData<Balance>;\n\t\/\/\/ Weight information for the extrinsics of this pallet.\n\ttype SystemWeightInfo = ();\n}\n\nimpl pallet_aura::Trait for Runtime {\n\ttype AuthorityId = AuraId;\n}\n\nimpl pallet_grandpa::Trait for Runtime {\n\ttype Event = Event;\n\ttype Call = Call;\n\n\ttype KeyOwnerProofSystem = ();\n\n\ttype KeyOwnerProof =\n\t\t<Self::KeyOwnerProofSystem as KeyOwnerProofSystem<(KeyTypeId, GrandpaId)>>::Proof;\n\n\ttype KeyOwnerIdentification = <Self::KeyOwnerProofSystem as KeyOwnerProofSystem<(\n\t\tKeyTypeId,\n\t\tGrandpaId,\n\t)>>::IdentificationTuple;\n\n\ttype HandleEquivocation = ();\n\n\ttype WeightInfo = ();\n}\n\nparameter_types! {\n\tpub const MinimumPeriod: u64 = SLOT_DURATION \/ 2;\n}\n\nimpl pallet_timestamp::Trait for Runtime {\n\t\/\/\/ A timestamp: milliseconds since the unix epoch.\n\ttype Moment = u64;\n\ttype OnTimestampSet = Aura;\n\ttype MinimumPeriod = MinimumPeriod;\n\ttype WeightInfo = ();\n}\n\nparameter_types! {\n\tpub const ExistentialDeposit: u128 = 500;\n\tpub const MaxLocks: u32 = 50;\n}\n\nimpl pallet_balances::Trait for Runtime {\n\ttype MaxLocks = MaxLocks;\n\t\/\/\/ The type for recording an account\'s balance.\n\ttype Balance = Balance;\n\t\/\/\/ The ubiquitous event type.\n\ttype Event = Event;\n\ttype DustRemoval = ();\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = ();\n}\n\nparameter_types! {\n\tpub const TransactionByteFee: Balance = 1;\n}\n\nimpl pallet_transaction_payment::Trait for Runtime {\n\ttype Currency = Balances;\n\ttype OnTransactionPayment = ();\n\ttype TransactionByteFee = TransactionByteFee;\n\ttype WeightToFee = IdentityFee<Balance>;\n\ttype FeeMultiplierUpdate = ();\n}\n\nimpl pallet_sudo::Trait for Runtime {\n\ttype Event = Event;\n\ttype Call = Call;\n}\n\nconstruct_runtime!(\n\tpub enum Runtime where\n\t\tBlock = Block,\n\t\tNodeBlock = opaque::Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic\n\t{\n\t\tSystem: frame_system::{Module, Call, Config, Storage, Event<T>},\n\t\tRandomnessCollectiveFlip: pallet_randomness_collective_flip::{Module, Call, Storage},\n\t\tTimestamp: pallet_timestamp::{Module, Call, Storage, Inherent},\n\t\tAura: pallet_aura::{Module, Config<T>, Inherent},\n\t\tGrandpa: pallet_grandpa::{Module, Call, Storage, Config, Event},\n\t\tBalances: pallet_balances::{Module, Call, Storage, Config<T>, Event<T>},\n\t\tTransactionPayment: pallet_transaction_payment::{Module, Storage},\n\t\tSudo: pallet_sudo::{Module, Call, Config<T>, Storage, Event<T>},\n\t}\n);\n\n\/\/\/ The address format for describing accounts.\npub type Address = AccountId;\n\/\/\/ Block header type as expected by this runtime.\npub type Header = generic::Header<BlockNumber, BlakeTwo256>;\n\/\/\/ Block type as expected by this runtime.\npub type Block = generic::Block<Header, UncheckedExtrinsic>;\n\/\/\/ A Block signed with a Justification\npub type SignedBlock = generic::SignedBlock<Block>;\n\/\/\/ BlockId type as expected by this runtime.\npub type BlockId = generic::BlockId<Block>;\n\/\/\/ The SignedExtension to the basic transaction logic.\npub type SignedExtra = (\n\tframe_system::CheckSpecVersion<Runtime>,\n\tframe_system::CheckTxVersion<Runtime>,\n\tframe_system::CheckGenesis<Runtime>,\n\tframe_system::CheckEra<Runtime>,\n\tframe_system::CheckNonce<Runtime>,\n\tframe_system::CheckWeight<Runtime>,\n\tpallet_transaction_payment::ChargeTransactionPayment<Runtime>\n);\n\/\/\/ Unchecked extrinsic type as expected by this runtime.\npub type UncheckedExtrinsic = generic::UncheckedExtrinsic<Address, Call, Signature, SignedExtra>;\n\/\/\/ Extrinsic type that has already been checked.\npub type CheckedExtrinsic = generic::CheckedExtrinsic<AccountId, Call, SignedExtra>;\n\/\/\/ Executive: handles dispatch to the various modules.\npub type Executive = frame_executive::Executive<\n\tRuntime,\n\tBlock,\n\tframe_system::ChainContext<Runtime>,\n\tRuntime,\n\tAllModules,\n>;\n\nimpl_runtime_apis! {\n\timpl sp_api::Core<Block> for Runtime {\n\t\tfn version() -> RuntimeVersion {\n\t\t\tVERSION\n\t\t}\n\n\t\tfn execute_block(block: Block) {\n\t\t\tExecutive::execute_block(block)\n\t\t}\n\n\t\tfn initialize_block(header: &<Block as BlockT>::Header) {\n\t\t\tExecutive::initialize_block(header)\n\t\t}\n\t}\n\n\timpl sp_api::Metadata<Block> for Runtime {\n\t\tfn metadata() -> OpaqueMetadata {\n\t\t\tRuntime::metadata().into()\n\t\t}\n\t}\n\n\timpl sp_block_builder::BlockBuilder<Block> for Runtime {\n\t\tfn apply_extrinsic(extrinsic: <Block as BlockT>::Extrinsic) -> ApplyExtrinsicResult {\n\t\t\tExecutive::apply_extrinsic(extrinsic)\n\t\t}\n\n\t\tfn finalize_block() -> <Block as BlockT>::Header {\n\t\t\tExecutive::finalize_block()\n\t\t}\n\n\t\tfn inherent_extrinsics(data: sp_inherents::InherentData) -> Vec<<Block as BlockT>::Extrinsic> {\n\t\t\tdata.create_extrinsics()\n\t\t}\n\n\t\tfn check_inherents(\n\t\t\tblock: Block,\n\t\t\tdata: sp_inherents::InherentData,\n\t\t) -> sp_inherents::CheckInherentsResult {\n\t\t\tdata.check_extrinsics(&block)\n\t\t}\n\n\t\tfn random_seed() -> <Block as BlockT>::Hash {\n\t\t\tRandomnessCollectiveFlip::random_seed()\n\t\t}\n\t}\n\n\timpl sp_transaction_pool::runtime_api::TaggedTransactionQueue<Block> for Runtime {\n\t\tfn validate_transaction(\n\t\t\tsource: TransactionSource,\n\t\t\ttx: <Block as BlockT>::Extrinsic,\n\t\t) -> TransactionValidity {\n\t\t\tExecutive::validate_transaction(source, tx)\n\t\t}\n\t}\n\n\timpl sp_offchain::OffchainWorkerApi<Block> for Runtime {\n\t\tfn offchain_worker(header: &<Block as BlockT>::Header) {\n\t\t\tExecutive::offchain_worker(header)\n\t\t}\n\t}\n\n\timpl sp_consensus_aura::AuraApi<Block, AuraId> for Runtime {\n\t\tfn slot_duration() -> u64 {\n\t\t\tAura::slot_duration()\n\t\t}\n\n\t\tfn authorities() -> Vec<AuraId> {\n\t\t\tAura::authorities()\n\t\t}\n\t}\n\n\timpl sp_session::SessionKeys<Block> for Runtime {\n\t\tfn generate_session_keys(seed: Option<Vec<u8>>) -> Vec<u8> {\n\t\t\topaque::SessionKeys::generate(seed)\n\t\t}\n\n\t\tfn decode_session_keys(\n\t\t\tencoded: Vec<u8>,\n\t\t) -> Option<Vec<(Vec<u8>, KeyTypeId)>> {\n\t\t\topaque::SessionKeys::decode_into_raw_public_keys(&encoded)\n\t\t}\n\t}\n\n\timpl fg_primitives::GrandpaApi<Block> for Runtime {\n\t\tfn grandpa_authorities() -> GrandpaAuthorityList {\n\t\t\tGrandpa::grandpa_authorities()\n\t\t}\n\n\t\tfn submit_report_equivocation_unsigned_extrinsic(\n\t\t\t_equivocation_proof: fg_primitives::EquivocationProof<\n\t\t\t\t<Block as BlockT>::Hash,\n\t\t\t\tNumberFor<Block>,\n\t\t\t>,\n\t\t\t_key_owner_proof: fg_primitives::OpaqueKeyOwnershipProof,\n\t\t) -> Option<()> {\n\t\t\tNone\n\t\t}\n\n\t\tfn generate_key_ownership_proof(\n\t\t\t_set_id: fg_primitives::SetId,\n\t\t\t_authority_id: GrandpaId,\n\t\t) -> Option<fg_primitives::OpaqueKeyOwnershipProof> {\n\t\t\t\/\/ NOTE: this is the only implementation possible since we\'ve\n\t\t\t\/\/ defined our key owner proof type as a bottom type (i.e. a type\n\t\t\t\/\/ with no values).\n\t\t\tNone\n\t\t}\n\t}\n\n\timpl frame_system_rpc_runtime_api::AccountNonceApi<Block, AccountId, Index> for Runtime {\n\t\tfn account_nonce(account: AccountId) -> Index {\n\t\t\tSystem::account_nonce(account)\n\t\t}\n\t}\n\n\timpl pallet_transaction_payment_rpc_runtime_api::TransactionPaymentApi<Block, Balance> for Runtime {\n\t\tfn query_info(\n\t\t\tuxt: <Block as BlockT>::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -> pallet_transaction_payment_rpc_runtime_api::RuntimeDispatchInfo<Balance> {\n\t\t\tTransactionPayment::query_info(uxt, len)\n\t\t}\n\t}\n\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\timpl frame_benchmarking::Benchmark<Block> for Runtime {\n\t\tfn dispatch_benchmark(\n\t\t\tconfig: frame_benchmarking::BenchmarkConfig\n\t\t) -> Result<Vec<frame_benchmarking::BenchmarkBatch>, sp_runtime::RuntimeString> {\n\t\t\tuse frame_benchmarking::{Benchmarking, BenchmarkBatch, add_benchmark, TrackedStorageKey};\n\n\t\t\tuse frame_system_benchmarking::Module as SystemBench;\n\t\t\timpl frame_system_benchmarking::Trait for Runtime {}\n\n\t\t\tlet whitelist: Vec<TrackedStorageKey> = vec![\n\t\t\t\t\/\/ Block Number\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef702a5c1b19ab7a04f536c519aca4983ac\").to_vec().into(),\n\t\t\t\t\/\/ Total Issuance\n\t\t\t\thex_literal::hex!(\"c2261276cc9d1f8598ea4b6a74b15c2f57c875e4cff74148e4628f264b974c80\").to_vec().into(),\n\t\t\t\t\/\/ Execution Phase\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef7ff553b5a9862a516939d82b3d3d8661a\").to_vec().into(),\n\t\t\t\t\/\/ Event Count\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef70a98fdbe9ce6c55837576c60c7af3850\").to_vec().into(),\n\t\t\t\t\/\/ System Events\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\").to_vec().into(),\n\t\t\t];\n\n\t\t\tlet mut batches = Vec::<BenchmarkBatch>::new();\n\t\t\tlet params = (&config, &whitelist);\n\n\t\t\tadd_benchmark!(params, batches, frame_system, SystemBench::<Runtime>);\n\t\t\tadd_benchmark!(params, batches, pallet_balances, Balances);\n\t\t\tadd_benchmark!(params, batches, pallet_timestamp, Timestamp);\n\n\t\t\tif batches.is_empty() { return Err(\"Benchmark not found for this pallet.\".into()) }\n\t\t\tOk(batches)\n\t\t}\n\t}\n}\n';
const chainSpecCode = 'use sp_core::{Pair, Public, sr25519};\nuse node_template_runtime::{\n\tAccountId, AuraConfig, BalancesConfig, GenesisConfig, GrandpaConfig,\n\tSudoConfig, SystemConfig, WASM_BINARY, Signature\n};\nuse sp_consensus_aura::sr25519::AuthorityId as AuraId;\nuse sp_finality_grandpa::AuthorityId as GrandpaId;\nuse sp_runtime::traits::{Verify, IdentifyAccount};\nuse sc_service::ChainType;\nuse sp_runtime::{Perbill};\n\n\/\/Additional code\n\n\/\/ The URL for the telemetry server.\n\/\/ const STAGING_TELEMETRY_URL: &str = \"wss:\/\/telemetry.polkadot.io\/submit\/\";\n\n\/\/\/ Specialized `ChainSpec`. This is a specialization of the general Substrate ChainSpec type.\npub type ChainSpec = sc_service::GenericChainSpec<GenesisConfig>;\n\n\/\/\/ Generate a crypto pair from seed.\npub fn get_from_seed<TPublic: Public>(seed: &str) -> <TPublic::Pair as Pair>::Public {\n\tTPublic::Pair::from_string(&format!(\"\/\/{}\", seed), None)\n\t\t.expect(\"static values are valid; qed\")\n\t\t.public()\n}\n\ntype AccountPublic = <Signature as Verify>::Signer;\n\n\/\/\/ Generate an account ID from seed.\npub fn get_account_id_from_seed<TPublic: Public>(seed: &str) -> AccountId where\n\tAccountPublic: From<<TPublic::Pair as Pair>::Public>\n{\n\tAccountPublic::from(get_from_seed::<TPublic>(seed)).into_account()\n}\n\n\/\/\/ Generate an Aura authority key.\npub fn authority_keys_from_seed(s: &str) -> (AuraId, GrandpaId) {\n\t(\n\t\tget_from_seed::<AuraId>(s),\n\t\tget_from_seed::<GrandpaId>(s),\n\t)\n}\n\npub fn development_config() -> Result<ChainSpec, String> {\n\tlet wasm_binary = WASM_BINARY.ok_or(\"Development wasm binary not available\".to_string())?;\n\n\tOk(ChainSpec::from_genesis(\n\t\t\/\/ Name\n\t\t\"Development\",\n\t\t\/\/ ID\n\t\t\"dev\",\n\t\tChainType::Development,\n\t\tmove || testnet_genesis(\n\t\t\twasm_binary,\n\t\t\t\/\/ Initial PoA authorities\n\t\t\tvec![\n\t\t\t\tauthority_keys_from_seed(\"Alice\"),\n\t\t\t],\n\t\t\t\/\/ Sudo account\n\t\t\tget_account_id_from_seed::<sr25519::Public>(\"Alice\"),\n\t\t\t\/\/ Pre-funded accounts\n\t\t\tvec![\n\t\t\t\tget_account_id_from_seed::<sr25519::Public>(\"Alice\"),\n\t\t\t\tget_account_id_from_seed::<sr25519::Public>(\"Bob\"),\n\t\t\t\tget_account_id_from_seed::<sr25519::Public>(\"Alice\/\/stash\"),\n\t\t\t\tget_account_id_from_seed::<sr25519::Public>(\"Bob\/\/stash\"),\n\t\t\t],\n\t\t\ttrue,\n\t\t),\n\t\t\/\/ Bootnodes\n\t\tvec![],\n\t\t\/\/ Telemetry\n\t\tNone,\n\t\t\/\/ Protocol ID\n\t\tNone,\n\t\t\/\/ Properties\n\t\tNone,\n\t\t\/\/ Extensions\n\t\tNone,\n\t))\n}\n\npub fn local_testnet_config() -> Result<ChainSpec, String> {\n\tlet wasm_binary = WASM_BINARY.ok_or(\"Development wasm binary not available\".to_string())?;\n\n\tOk(ChainSpec::from_genesis(\n\t\t\/\/ Name\n\t\t\"Local Testnet\",\n\t\t\/\/ ID\n\t\t\"local_testnet\",\n\t\tChainType::Local,\n\t\tmove || testnet_genesis(\n\t\t\twasm_binary,\n\t\t\t\/\/ Initial PoA authorities\n\t\t\tvec![\n\t\t\t\tauthority_keys_from_seed(\"Alice\"),\n\t\t\t\tauthority_keys_from_seed(\"Bob\"),\n\t\t\t],\n\t\t\t\/\/ Sudo account\n\t\t\tget_account_id_from_seed::<sr25519::Public>(\"Alice\"),\n\t\t\t\/\/ Pre-funded accounts\n\t\t\tvec![\n\t\t\t\tget_account_id_from_seed::<sr25519::Public>(\"Alice\"),\n\t\t\t\tget_account_id_from_seed::<sr25519::Public>(\"Bob\"),\n\t\t\t\tget_account_id_from_seed::<sr25519::Public>(\"Charlie\"),\n\t\t\t\tget_account_id_from_seed::<sr25519::Public>(\"Dave\"),\n\t\t\t\tget_account_id_from_seed::<sr25519::Public>(\"Eve\"),\n\t\t\t\tget_account_id_from_seed::<sr25519::Public>(\"Ferdie\"),\n\t\t\t\tget_account_id_from_seed::<sr25519::Public>(\"Alice\/\/stash\"),\n\t\t\t\tget_account_id_from_seed::<sr25519::Public>(\"Bob\/\/stash\"),\n\t\t\t\tget_account_id_from_seed::<sr25519::Public>(\"Charlie\/\/stash\"),\n\t\t\t\tget_account_id_from_seed::<sr25519::Public>(\"Dave\/\/stash\"),\n\t\t\t\tget_account_id_from_seed::<sr25519::Public>(\"Eve\/\/stash\"),\n\t\t\t\tget_account_id_from_seed::<sr25519::Public>(\"Ferdie\/\/stash\"),\n\t\t\t],\n\t\t\ttrue,\n\t\t),\n\t\t\/\/ Bootnodes\n\t\tvec![],\n\t\t\/\/ Telemetry\n\t\tNone,\n\t\t\/\/ Protocol ID\n\t\tNone,\n\t\t\/\/ Properties\n\t\tNone,\n\t\t\/\/ Extensions\n\t\tNone,\n\t))\n}\n\nfn session_keys(\n\taura: AuraId,\n\tgrandpa: GrandpaId,\n) -> SessionKeys {\n\tSessionKeys { aura, grandpa }\n}\n\n\/\/\/ Configure initial storage state for FRAME modules.\nfn testnet_genesis(\n\twasm_binary: &[u8],\n\tinitial_authorities: Vec<(AuraId, GrandpaId)>,\n\troot_key: AccountId,\n\tendowed_accounts: Vec<AccountId>,\n\t_enable_println: bool,\n) -> GenesisConfig {\n\t\/\/Additional genesis variables\n\n\tGenesisConfig {\n\t\tframe_system: Some(SystemConfig {\n\t\t\t\/\/ Add Wasm runtime to storage.\n\t\t\tcode: wasm_binary.to_vec(),\n\t\t\tchanges_trie_config: Default::default(),\n\t\t}),\n\t\tpallet_balances: Some(BalancesConfig {\n\t\t\t\/\/ Configure endowed accounts with initial balance of 1 << 60.\n\t\t\tbalances: endowed_accounts.iter().cloned().map(|k|(k, 1 << 60)).collect(),\n\t\t}),\n\t\tpallet_aura: Some(AuraConfig {\n\t\t\tauthorities: initial_authorities.iter().map(|x| (x.0.clone())).collect(),\n\t\t}),\n\t\tpallet_grandpa: Some(GrandpaConfig {\n\t\t\tauthorities: initial_authorities.iter().map(|x| (x.1.clone(), 1)).collect(),\n\t\t}),\n\t\tpallet_sudo: Some(SudoConfig {\n\t\t\t\/\/ Assign network admin rights.\n\t\t\tkey: root_key,\n\t\t}),\n\t}\n}\n';

describe('Runtime and genesis are generated correctly for provided pallet', () => {

  const palletConfig = PalletValidatorSetConfig;
  const palletName = 'substrate-validator-set';
  const palletAlias = 'validator-set';

  const utilInstance = new SubstrateRuntimeUtil(palletConfig, runtimeLibCode, chainSpecCode);

  test(`Pallet name should be ${palletName}`, () => {
    expect(utilInstance.palletName).toEqual(palletName);
  })
  test(`Pallet alias should be ${palletAlias}`, () => {
    expect(utilInstance.palletAlias).toEqual(palletAlias);
  })

  const {
    runtimeLib: newRuntimeLibCode,
    chainSpec: newChainSpecCode
  } = utilInstance.generateCode();

  test("Pallet trait implementation is generated", () => {
    expect(
      newRuntimeLibCode.includes(`impl validator_set::Trait for Runtime`)
    ).toBeTruthy();
  })

  test("All traits are implemented", () => {
    let areAllTraitsPresent =
      newRuntimeLibCode.includes('type Event = Event');

    expect(areAllTraitsPresent).toBeTruthy();
  })

  test("Are all genesis fields implemented", () => {
    let areAllGenesisFieldsPresent =
      newChainSpecCode.includes('validators: vec![get_account_id_from_seed::<sr25519::Public>("Alice")]');

    expect(areAllGenesisFieldsPresent).toBeTruthy();
  })

  test("Is additional runtime code implemented", () => {
    const additionalCode = palletConfig.runtime.additionalRuntimeLibCode;

    const isAdditionalCodeMissing =additionalCode?.map(code => (
      newRuntimeLibCode.includes(code)
    )).includes(false);

    expect(isAdditionalCodeMissing).toBeFalsy();
  })

  test("Is additional chainspec code implemented", () => {
    const {
      additionalCode,
      additionalVariables
    } = palletConfig.runtime.additionalChainSpecCode;

    const isAdditionalCodeMissing = additionalCode?.map(code => (
      newChainSpecCode.includes(code)
    )).includes(false);

    const areAdditionalVariablesMissing = additionalVariables?.map(code => (
      newChainSpecCode.includes(code)
    )).includes(false);

    expect(isAdditionalCodeMissing || areAdditionalVariablesMissing).toBeFalsy();
  })
})
